# DISCLAIMER

Below is a list of concerns that should be taken into consideration in the current version.

1 - Lack of State Root Verification in GIO Responses:

Currently, the application relies on an external API ( GIO - domain 0x27 ) to fetch Ethereum contract storage data, but this API does not yet implement state root verification. This introduces a potential trust issue, as we cannot independently verify the integrity and authenticity of the returned data.

Without cross-checking the retrieved storage values against the stateRoot of the corresponding block, we are inherently trusting the API to provide correct and untampered data. This leaves the system vulnerable to:

- Malicious or compromised API nodes providing falsified storage values.
- Outdated or inconsistent data if the API does not correctly synchronize with the blockchain.
- Lack of cryptographic guarantees regarding the correctness of the returned state.

To mitigate these risks, we should consider implementing verification using eth_getProof, which provides Merkle proofs for account storage. By validating these proofs against the stateRoot of the target block, we can ensure that the fetched storage values were indeed part of Ethereum’s canonical state at that block height.

2 - Non-blocking Execution:

Currently, we do not have a queue system for processing outputs in the coprocessor, and we do not block the processing of a new input if there are not yet **N** confirmations that the output generated by the previous input has been executed. This is a problem in the following analogous scenario:  

We have a contract that stores swap orders, and our backend within the coprocessor reads the state of this array via **GIO**, for example. Each order has a status that gets updated upon execution. Our backend logic works as follows:  
- If the status is **A**, with **A** being arbitrary, we use that order for matching in the order book.  
- If the status is **B**, with **B** being arbitrary, we do not use it because it has already been executed.  

Now, considering the inputs/tasks in the system:  
- **Input A**: Signals that a new order has been submitted and checks if there are orders in the previous block (there aren’t).  
- **Input B**: Signals a new order, reads the order from the previous block, and tries to match them (eventually, a match occurs, and a notice is issued for the actual swap execution).  
- **Input C**: Also introduces a new order.  

This concern is based on behavior we observed on Otterscan. This is the order of transactions:  

1st Swap order **A** is created.  
2nd Swap order **B** is created.  
3rd Swap order **C** is created.  
4th The swap is executed between **A** and **B** (orders only change status when executed).  

Thus, there is a possibility that swap **C** might be reading the outdated status of orders **A** and **B**.
